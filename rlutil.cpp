/**
 * File: rlutil.h
 *
 * About: Description
 * This file provides some useful utilities for console mode
 * roguelike game development with C and C++. It is aimed to
 * be cross-platform (at least Windows and Linux).
 *
 * About: Copyright
 * (C) 2010 Tapio Vierros
 *
 * About: Licensing
 * See <License>
 */

#include "rlutil.h"


#ifndef WIN32

/// Function: getch
/// Get character without waiting for Return to be pressed.
/// Windows has this in conio.h
int getch()
{
    // Here be magic.
    struct termios oldt, newt;
    int ch;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    ch = getchar();
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return ch;
}

/// Function: kbhit
/// Determines if keyboard has been hit.
/// Windows has this in conio.h
int kbhit()
{
    // Here be dragons.
    static struct termios oldt, newt;
    int cnt = 0;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag    &= ~(ICANON | ECHO);
    newt.c_iflag     = 0; // input mode
    newt.c_oflag     = 0; // output mode
    newt.c_cc[VMIN]  = 1; // minimum time to wait
    newt.c_cc[VTIME] = 1; // minimum characters to wait for
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    ioctl(0, FIONREAD, &cnt); // Read count
    struct timeval tv;
    tv.tv_sec  = 0;
    tv.tv_usec = 100;
    select(STDIN_FILENO+1, NULL, NULL, NULL, &tv); // A small time delay
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return cnt; // Return number of characters
}
#endif // WIN32

#ifndef gotoxy
/// Function: gotoxy
/// Same as <rlutil.locate>.
void gotoxy(int x, int y)
{
#ifdef __cplusplus
    rlutil::
#endif
    locate(x,y);
}
#endif // gotoxy

#ifdef __cplusplus
/// Namespace: rlutil
/// In C++ all functions except <getch>, <kbhit> and <gotoxy> are arranged
/// under namespace rlutil. That is because some platforms have them defined
/// outside of rlutil.
namespace rlutil
{
#endif

/**
 * Defs: Internal typedefs and macros
 * RLUTIL_STRING_T - String type depending on which one of C or C++ is used
 * RLUTIL_PRINT(str) - Printing macro independent of C/C++
 */

#ifdef __cplusplus
#ifndef RLUTIL_STRING_T
typedef std::string RLUTIL_STRING_T;
#endif // RLUTIL_STRING_T

void RLUTIL_PRINT(RLUTIL_STRING_T st)
{
    std::cout << st;
}

#endif // __cplusplus

/// Function: getkey
/// Reads a key press (blocking) and returns a key code.
///
/// See <Key codes for keyhit()>
///
/// Note:
/// Only Arrows, Esc, Enter and Space are currently working properly.
int getkey(void)
{
#ifndef WIN32
    int cnt = kbhit(); // for ANSI escapes processing
#endif
    int k = getch();
    switch(k)
    {
    case 0:
    {
        int kk;
        switch (kk = getch())
        {
        case 71:
            return KEY_NUMPAD7;
        case 72:
            return KEY_NUMPAD8;
        case 73:
            return KEY_NUMPAD9;
        case 75:
            return KEY_NUMPAD4;
        case 77:
            return KEY_NUMPAD6;
        case 79:
            return KEY_NUMPAD1;
        case 80:
            return KEY_NUMPAD4;
        case 81:
            return KEY_NUMPAD3;
        case 82:
            return KEY_NUMPAD0;
        case 83:
            return KEY_NUMDEL;
        default:
            return kk-59+KEY_F1; // Function keys
        }
    }
    case 224:
    {
        int kk;
        switch (kk = getch())
        {
        case 71:
            return KEY_HOME;
        case 72:
            return KEY_UP;
        case 73:
            return KEY_PGUP;
        case 75:
            return KEY_LEFT;
        case 77:
            return KEY_RIGHT;
        case 79:
            return KEY_END;
        case 80:
            return KEY_DOWN;
        case 81:
            return KEY_PGDOWN;
        case 82:
            return KEY_INSERT;
        case 83:
            return KEY_DELETE;
        default:
            return kk-123+KEY_F1; // Function keys
        }
    }
    case 13:
        return KEY_ENTER;
#ifdef WIN32
    case 27:
        return KEY_ESCAPE;
#else // WIN32
    case 155: // single-character CSI
    case 27:
    {
        // Process ANSI escape sequences
        if (cnt >= 3 && getch() == '[')
        {
            switch (k = getch())
            {
            case 'A':
                return KEY_UP;
            case 'B':
                return KEY_DOWN;
            case 'C':
                return KEY_RIGHT;
            case 'D':
                return KEY_LEFT;
            }
        }
        else return KEY_ESCAPE;
    }
#endif // WIN32
    default:
        return k;
    }
}

/// Function: nb_getch
/// Non-blocking getch(). Returns 0 if no key was pressed.
int nb_getch()
{
    if (kbhit()) return getch();
    else return 0;
}

/// Function: getANSIColor
/// Return ANSI color escape sequence for specified number 0-15.
///
/// See <Color Codes>
RLUTIL_STRING_T getANSIColor(const int c)
{
    switch (c)
    {
    case 0 :
        return ANSI_BLACK;
    case 1 :
        return ANSI_BLUE; // non-ANSI
    case 2 :
        return ANSI_GREEN;
    case 3 :
        return ANSI_CYAN; // non-ANSI
    case 4 :
        return ANSI_RED; // non-ANSI
    case 5 :
        return ANSI_MAGENTA;
    case 6 :
        return ANSI_BROWN;
    case 7 :
        return ANSI_GREY;
    case 8 :
        return ANSI_DARKGREY;
    case 9 :
        return ANSI_LIGHTBLUE; // non-ANSI
    case 10:
        return ANSI_LIGHTGREEN;
    case 11:
        return ANSI_LIGHTCYAN; // non-ANSI;
    case 12:
        return ANSI_LIGHTRED; // non-ANSI;
    case 13:
        return ANSI_LIGHTMAGENTA;
    case 14:
        return ANSI_YELLOW; // non-ANSI
    case 15:
        return ANSI_WHITE;
    default:
        return "";
    }
}

/// Function: setColor
/// Change color specified by number (Windows / QBasic colors).
///
/// See <Color Codes>
void setColor(int c)
{
#if defined(WIN32) && !defined(RLUTIL_USE_ANSI)
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, c);
#else
    RLUTIL_PRINT(getANSIColor(c));
#endif
}

/// Function: cls
/// Clears screen and moves cursor home.
void cls()
{
#if defined(WIN32) && !defined(RLUTIL_USE_ANSI)
    // TODO: This is cheating...
    system("cls");
#else
    RLUTIL_PRINT("\033[2J\033[H");
#endif
}

/// Function: locate
/// Sets the cursor position to 1-based x,y.
void locate(int x, int y)
{
#if defined(WIN32) && !defined(RLUTIL_USE_ANSI)
    COORD coord = {x-1, y-1}; // Windows uses 0-based coordinates
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
#else // WIN32 || USE_ANSI
#ifdef __cplusplus
    std::ostringstream oss;
    oss << "\033[" << y << ";" << x << "H";
    RLUTIL_PRINT(oss.str());
#else // __cplusplus
    char buf[32];
    sprintf(buf, "\033[%d;%df", y, x);
    RLUTIL_PRINT(buf);
#endif // __cplusplus
#endif // WIN32 || USE_ANSI
}

/// Function: hidecursor
/// Hides the cursor.
void hidecursor()
{
#if defined(WIN32) && !defined(RLUTIL_USE_ANSI)
    HANDLE hConsoleOutput;
    CONSOLE_CURSOR_INFO structCursorInfo;
    hConsoleOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleCursorInfo( hConsoleOutput, &structCursorInfo ); // Get current cursor size
    structCursorInfo.bVisible = FALSE;
    SetConsoleCursorInfo( hConsoleOutput, &structCursorInfo );
#else // WIN32 || USE_ANSI
    RLUTIL_PRINT("\033[?25l");
#endif // WIN32 || USE_ANSI
}

/// Function: showcursor
/// Shows the cursor.
void showcursor()
{
#if defined(WIN32) && !defined(RLUTIL_USE_ANSI)
    HANDLE hConsoleOutput;
    CONSOLE_CURSOR_INFO structCursorInfo;
    hConsoleOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    GetConsoleCursorInfo( hConsoleOutput, &structCursorInfo ); // Get current cursor size
    structCursorInfo.bVisible = TRUE;
    SetConsoleCursorInfo( hConsoleOutput, &structCursorInfo );
#else // WIN32 || USE_ANSI
    RLUTIL_PRINT("\033[?25h");
#endif // WIN32 || USE_ANSI
}

/// Function: msleep
/// Waits given number of milliseconds before continuing.
void msleep(unsigned int ms)
{
#ifdef WIN32
    Sleep(ms);
#else
    // usleep argument must be under 1 000 000
    if (ms > 1000) sleep(ms/1000000);
    usleep((ms % 1000000) * 1000);
#endif
}

/// Function: trows
/// Get the number of rows in the terminal window or -1 on error.
int trows()
{
#ifdef WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))
        return -1;
    else
        return csbi.srWindow.Bottom - csbi.srWindow.Top + 1; // Window height
    // return csbi.dwSize.Y; // Buffer height
#else
#ifdef TIOCGSIZE
    struct ttysize ts;
    ioctl(STDIN_FILENO, TIOCGSIZE, &ts);
    return ts.ts_lines;
#elif defined(TIOCGWINSZ)
    struct winsize ts;
    ioctl(STDIN_FILENO, TIOCGWINSZ, &ts);
    return ts.ws_row;
#else // TIOCGSIZE
    return -1;
#endif // TIOCGSIZE
#endif // WIN32
}

/// Function: tcols
/// Get the number of columns in the terminal window or -1 on error.
int tcols()
{
#ifdef WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (!GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi))
        return -1;
    else
        return csbi.srWindow.Right - csbi.srWindow.Left + 1; // Window width
    // return csbi.dwSize.X; // Buffer width
#else
#ifdef TIOCGSIZE
    struct ttysize ts;
    ioctl(STDIN_FILENO, TIOCGSIZE, &ts);
    return ts.ts_cols;
#elif defined(TIOCGWINSZ)
    struct winsize ts;
    ioctl(STDIN_FILENO, TIOCGWINSZ, &ts);
    return ts.ws_col;
#else // TIOCGSIZE
    return -1;
#endif // TIOCGSIZE
#endif // WIN32
}

// TODO: Allow optional message for anykey()?

/// Function: anykey
/// Waits until a key is pressed.
void anykey()
{
    getch();
}


// Classes are here at the end so that documentation is pretty.

#ifdef __cplusplus
/// Class: CursorHider
/// RAII OOP wrapper for <rlutil.hidecursor>.
/// Hides the cursor and shows it again
/// when the object goes out of scope.

} // namespace rlutil
#endif

